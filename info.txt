  Usage examples:
  # Get pipette info
  python aspirate.py --info

  # Aspirate 25ul at speed 5 for 12.5ul pipette
  python aspirate.py --volume 25 --speed 5 --pipette-type 12.5ul

  # Aspirate with RUN key confirmation
  python aspirate.py --volume 10 --run-confirm --message "Test Run"



  #!/usr/bin/env python3
import serial
import argparse
import struct

def calculate_checksum(data):
    """Calculate checksum as per SPEC protocol"""
    checksum = sum(data) & 0xFF
    return (256 - checksum) & 0xFF

def build_message(msg_type, data=b'', seq_num=1):
    """Build message according to SPEC protocol"""
    # Message structure: STX + Length + Checksum + Seq + Resend + MsgType + Data + ETX
    stx = 0x02
    etx = 0x03
    resend_flag = 0x00
    
    # Calculate length (everything between STX and ETX, excluding ESC chars)
    msg_content = struct.pack('>H', 0) + struct.pack('B', 0) + struct.pack('>H', seq_num) + struct.pack('B', resend_flag) + struct.pack('>H', msg_type) + data
    length = len(msg_content)
    
    # Build message without checksum first
    temp_msg = struct.pack('>H', length) + struct.pack('B', 0) + struct.pack('>H', seq_num) + struct.pack('B', resend_flag) + struct.pack('>H', msg_type) + data
    
    # Calculate checksum
    checksum = calculate_checksum(temp_msg)
    
    # Build final message
    message = struct.pack('B', stx) + struct.pack('>H', length) + struct.pack('B', checksum) + struct.pack('>H', seq_num) + struct.pack('B', resend_flag) + struct.pack('>H', msg_type) + data + struct.pack('B', etx)
    
    return message

def parse_response(resp_bytes):
    """Parse response according to SPEC protocol"""
    if len(resp_bytes) < 9:
        print("Response too short!")
        return None
    
    idx = 0
    stx = resp_bytes[idx]; idx += 1
    length = struct.unpack('>H', resp_bytes[idx:idx+2])[0]; idx += 2
    checksum = resp_bytes[idx]; idx += 1
    seq = struct.unpack('>H', resp_bytes[idx:idx+2])[0]; idx += 2
    resend_flag = resp_bytes[idx]; idx += 1
    msg_type = struct.unpack('>H', resp_bytes[idx:idx+2])[0]; idx += 2
    
    # Status code (2 bytes) - present in responses
    if len(resp_bytes) > idx + 1:
        status_code = struct.unpack('>H', resp_bytes[idx:idx+2])[0]; idx += 2
    else:
        status_code = None
    
    data = resp_bytes[idx:-1] if len(resp_bytes) > idx+1 else b""
    etx = resp_bytes[-1]
    
    print(f"STX:         {stx:#04x}")
    print(f"Length:      {length}")
    print(f"Checksum:    {checksum:#04x}")
    print(f"Seq:         {seq}")
    print(f"Resend flag: {resend_flag}")
    print(f"Msg type:    {msg_type:#06x}")
    print(f"Status code: {status_code:#04x}" if status_code is not None else "Status code: None")
    print(f"Data:        {data.hex() if data else '<none>'}")
    print(f"ETX:         {etx:#04x}")
    
    # Status code mapping from SPEC
    status_meaning = {
        0x00: "Command accepted (OK)",
        0x01: "Unknown message type (protocol error)",
        0x02: "Value/parameter out of range or wrong number of bytes",
        0x03: "Hardware error - check pipette status",
        0x04: "Command not accepted - action or state invalid",
    }
    
    desc = status_meaning.get(status_code, f"Unknown status code: {status_code:#04x}")
    print(f"Status desc: {desc}")
    
    return {
        'status_code': status_code,
        'data': data,
        'msg_type': msg_type
    }

def get_volume_factor_and_range(pipette_type):
    """Get volume factor and range based on pipette type from SPEC"""
    configs = {
        '12.5ul': {'factor': 1000, 'min': 50, 'max': 125},  # 0.05-0.125ul range
        '50ul': {'factor': 100, 'min': 100, 'max': 5000},   # 1-50ul range  
        '125ul': {'factor': 100, 'min': 20, 'max': 1250},   # 0.2-12.5ul range
        '300ul': {'factor': 10, 'min': 5, 'max': 3100},     # 0.5-310ul range
        '1250ul': {'factor': 10, 'min': 25, 'max': 12500},  # 2.5-1250ul range
        '5000ul': {'factor': 1, 'min': 100, 'max': 50000}   # 100-5000ul range
    }
    return configs.get(pipette_type, configs['50ul'])  # Default to 50ul

def send_aspirate_command(volume_ul, speed=8, mix_cycles=0, message="Integra", 
                         run_confirm=False, pipette_type='50ul', port='/dev/tty.usbserial-FT3LK3ZO'):
    """Send aspirate command according to SPEC protocol"""
    
    # Get pipette configuration and validate volume
    config = get_volume_factor_and_range(pipette_type)
    factor = config['factor']
    volume_value = int(volume_ul * factor)
    
    # Validate volume range
    if volume_value < config['min'] or volume_value > config['max']:
        print(f"ERROR: Volume {volume_ul}ul is out of range for {pipette_type} pipette")
        print(f"Valid range: {config['min']/factor:.2f}ul - {config['max']/factor:.2f}ul")
        return None
    
    # Build data payload for Set Action command (Type 5)
    data = struct.pack('B', 1)  # Action: 1 = Aspirate
    data += struct.pack('B', speed)  # Speed: 1-10
    data += struct.pack('>H', volume_value)  # Volume (2 bytes, big endian)
    data += struct.pack('B', mix_cycles)  # Mix cycles: 1-30
    data += struct.pack('B', 1 if run_confirm else 0)  # RUN confirmation
    
    # Message string (20 bytes, padded with spaces)
    msg_bytes = message.encode('ascii')[:20].ljust(20, b' ')
    data += msg_bytes
    
    data += struct.pack('>H', 0)  # Spacing (2 bytes, 0 for non-spacing action)
    
    # Build complete message
    cmd = build_message(0x0005, data)  # Message type 5: Set Action
    
    print(f"Sending aspirate command:")
    print(f"Volume: {volume_ul}ul (factor: {factor}, value: {volume_value})")
    print(f"Speed: {speed}")
    print(f"Message: '{message}'")
    print(f"Command bytes: {cmd.hex()}")
    
    try:
        with serial.Serial(port, baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=5) as ser:
            ser.write(cmd)
            
            # Read response - try multiple times
            response = ser.read(64)
            if not response:
                print("No immediate response, waiting longer...")
                response = ser.read(64)
            
            if response:
                print(f"\nResponse received ({len(response)} bytes): {response.hex()}")
                result = parse_response(response)
                return result
            else:
                print("No response received")
                # Check if there are any bytes in the buffer
                if ser.in_waiting > 0:
                    delayed_response = ser.read(ser.in_waiting)
                    print(f"Found delayed response: {delayed_response.hex()}")
                    result = parse_response(delayed_response)
                    return result
                return None
                
    except serial.SerialException as e:
        print(f"Serial error: {e}")
        return None
    except Exception as e:
        print(f"Error: {e}")
        return None

def send_get_action_status(port='/dev/tty.usbserial-FT3LK3ZO'):
    """Send Get Action Status command (Type 2)"""
    cmd = build_message(0x0002)  # Message type 2: Get Action Status
    
    try:
        with serial.Serial(port, baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=2) as ser:
            ser.write(cmd)
            response = ser.read(64)
            if response:
                result = parse_response(response)
                if result and result['data']:
                    action_status = result['data'][0] if len(result['data']) > 0 else None
                    status_meanings = {
                        0: "Ready",
                        1: "Wait for BlowIn",
                        2: "Wait for RUN Key", 
                        3: "Busy",
                        4: "Pipette not homed",
                        5: "User abort",
                        6: "Error Spacer",
                        7: "Battery too low"
                    }
                    status_desc = status_meanings.get(action_status, f"Unknown status: {action_status}")
                    print(f"Action Status: {action_status} - {status_desc}")
                return result
            else:
                print("No response received")
                return None
    except Exception as e:
        print(f"Error: {e}")
        return None

def send_get_info(port='/dev/tty.usbserial-FT3LK3ZO'):
    """Send Get Info command (Type 1)"""
    cmd = build_message(0x0001)  # Message type 1: Get Info
    
    print(f"Sending Get Info command: {cmd.hex()}")
    
    try:
        with serial.Serial(port, baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=2) as ser:
            ser.write(cmd)
            response = ser.read(64)
            if response:
                print(f"\nResponse: {response.hex()}")
                return parse_response(response)
            else:
                print("No response received")
                return None
    except Exception as e:
        print(f"Error: {e}")
        return None

def main():
    parser = argparse.ArgumentParser(description='Control INTEGRA VIAFLO pipette via SPEC protocol')
    parser.add_argument('--volume', type=float, default=10.0, help='Volume in microliters (default: 10.0)')
    parser.add_argument('--speed', type=int, default=8, choices=range(1, 11), help='Speed 1-10 (default: 8)')
    parser.add_argument('--mix-cycles', type=int, default=0, help='Mix cycles 0-30 (default: 0)')
    parser.add_argument('--message', type=str, default='Integra', help='Display message (max 20 chars)')
    parser.add_argument('--run-confirm', action='store_true', help='Require RUN key confirmation')
    parser.add_argument('--pipette-type', choices=['12.5ul', '50ul', '125ul', '300ul', '1250ul', '5000ul'], 
                       default='50ul', help='Pipette type for volume factor (default: 50ul)')
    parser.add_argument('--port', type=str, default='/dev/tty.usbserial-FT3LK3ZO', help='Serial port')
    parser.add_argument('--info', action='store_true', help='Get pipette info instead of aspirating')
    parser.add_argument('--status', action='store_true', help='Get pipette action status')
    
    args = parser.parse_args()
    
    if args.info:
        send_get_info(args.port)
    elif args.status:
        send_get_action_status(args.port)
    else:
        result = send_aspirate_command(
            volume_ul=args.volume,
            speed=args.speed,
            mix_cycles=args.mix_cycles,
            message=args.message,
            run_confirm=args.run_confirm,
            pipette_type=args.pipette_type,
            port=args.port
        )
        # Check status after aspirate command
        if result and result.get('status_code') == 0:
            print("\nChecking action status...")
            send_get_action_status(args.port)

if __name__ == '__main__':
    main()









    #########


    import serial

def parse_response(resp_bytes):
    if len(resp_bytes) < 9:
        print("Response too short!")
        return

    idx = 0
    stx = resp_bytes[idx]; idx += 1
    length = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2
    checksum = resp_bytes[idx]; idx += 1
    seq = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2
    resend_flag = resp_bytes[idx]; idx += 1
    msg_type = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2

    # Most responses will have at least a status code (2 bytes)
    if len(resp_bytes) > idx + 1:
        status_code = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2
    else:
        status_code = None

    data = resp_bytes[idx:-1] if len(resp_bytes) > idx+1 else b""
    etx = resp_bytes[-1]

    print(f"STX:         {stx:#04x}")
    print(f"Length:      {length}")
    print(f"Checksum:    {checksum:#04x}")
    print(f"Seq:         {seq}")
    print(f"Resend flag: {resend_flag}")
    print(f"Msg type:    {msg_type:#06x}")
    print(f"Status code: {status_code}")
    print(f"Data:        {data.hex() if data else '<none>'}")
    print(f"ETX:         {etx:#04x}")

    # Status code mapping
    status_meaning = {
        0x00: "Command accepted (OK)",
        0x01: "Unknown message type (protocol error)",
        0x02: "Value/parameter out of range or wrong number of bytes",
        0x03: "Hardware error - check pipette status",
        0x04: "Command not accepted - action or state invalid",
        0x64: "Unknown/custom status code (0x64) - check protocol documentation",
        # Add more codes here as needed
    }

    desc = status_meaning.get(status_code, None)
    if desc is not None:
        print(f"Status desc: {desc}")
    else:
        print(f"Status desc: Unknown code (dec: {status_code}, hex: {status_code:#04x}), see pipette manual.")



def send_aspirate_command(port='/dev/tty.usbserial-FT3LK3ZO'):
    # ... rest of code ...
    # The message as bytes (hex values)
    cmd = bytes([
        0x02, 0x00, 0x24, 0x64, 0x00, 0x00, 0x00, 0x00, 0x05, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x49, 0x6E, 0x74, 0x65, 0x67, 0x72, 0x61, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
        0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x03
    ])
    with serial.Serial(port, baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=1) as ser:
        ser.write(cmd)
        # read response
        response = ser.read(64)
        print("Response:", response.hex())
        parse_response(response)

# Run this script on a PC or Raspberry Pi with USB serial connected to the pipette.
send_aspirate_command()


def parse_response(resp_bytes):
    if len(resp_bytes) < 9:
        print("Response too short!")
        return

    idx = 0
    stx = resp_bytes[idx]; idx += 1
    length = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2
    checksum = resp_bytes[idx]; idx += 1
    seq = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2
    resend_flag = resp_bytes[idx]; idx += 1
    msg_type = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2

    # Most responses will have at least a status code (2 bytes)
    if len(resp_bytes) > idx + 1:
        status_code = (resp_bytes[idx] << 8) + resp_bytes[idx+1]; idx += 2
    else:
        status_code = None

    data = resp_bytes[idx:-1] if len(resp_bytes) > idx+1 else b""
    etx = resp_bytes[-1]

    print(f"STX:         {stx:#04x}")
    print(f"Length:      {length}")
    print(f"Checksum:    {checksum:#04x}")
    print(f"Seq:         {seq}")
    print(f"Resend flag: {resend_flag}")
    print(f"Msg type:    {msg_type:#06x}")
    print(f"Status code: {status_code}")
    print(f"Data:        {data.hex() if data else '<none>'}")
    print(f"ETX:         {etx:#04x}")

    # Status code mapping
    status_meaning = {
        0x00: "Command accepted (OK)",
        0x01: "Unknown message type (protocol error)",
        0x02: "Value/parameter out of range or wrong number of bytes",
        0x03: "Hardware error - check pipette status",
        0x04: "Command not accepted - action or state invalid",
        0x64: "Unknown/custom status code (0x64) - check protocol documentation",
        # Add more codes here as needed
    }

    desc = status_meaning.get(status_code, None)
    if desc is not None:
        print(f"Status desc: {desc}")
    else:
        print(f"Status desc: Unknown code (dec: {status_code}, hex: {status_code:#04x}), see pipette manual.")
